//****************************************   Day 8    **********************************************************
// *******************************  1768. Merge Strings Alternately   ******************************************
// You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with
// word1. If a string is longer than the other, append the additional letters onto the end of the merged string.

// Return the merged string.
/*
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function (word1, word2) {
    let n1 = word1.length;
    let n2 = word2.length;
    let n = 0;
    let nword = [];
    n1 > n2 ? n = n1 : n = n2;

    for (i = 0; i < n; i++) {

      word1.split("").splice(i, 1);
      nword.push(word1[i]);
      word2.split("").splice(i, 1);
      nword.push(word2[i]);
    }
    return nword;
  };
  console.log(mergeAlternately( "pqdffasdr","abcd"));


// **************************************   1678. Goal Parser Interpretation   **************************************
// You own a Goal Parser that can interpret a string command. The command consists of an alphabet of "G", 
// "()" and/or "(al)" in some order. The Goal Parser will interpret "G" as the string "G", "()" as the string "o",
//  and "(al)" as the string "al". The interpreted strings are then concatenated in the original order.

// Given the string command, return the Goal Parser's interpretation of command.

var interpret = function (command) {
    a=command.replace(/\(\)/gi, "o").replace(/\(al\)/gi,"al");
    return a;
  };




// **************************************   389. Find the Difference   **************************************
//   You are given two strings s and t.
// String t is generated by random shuffling string s and then add one more letter at a random position.
// Return the letter that was added to t.

var findTheDifference = function (s, t) {
    let s1=s.split("").sort();
    let t1=t.split("").sort();
  
    for (i = 0; i < t1.length; i++) {
      if (t1[i] !== s1[i]) {
        return t1[i];
      }
    }
  };
  console.log(
    findTheDifference(
      "ymbgaraibkfmvocpizdydugvalagaivdbfsfbepeyccqfepzvtpyxtbadkhmwmoswrcxnargtlswqemafandgkmydtimuzvjwxvlfwlhvkrgcsithaqlcvrihrwqkpjdhgfgreqoxzfvhjzojhghfwbvpfzectwwhexthbsndovxejsntmjihchaotbgcysfdaojkjldprwyrnischrgmtvjcorypvopfmegizfkvudubnejzfqffvgdoxohuinkyygbdzmshvyqyhsozwvlhevfepdvafgkqpkmcsikfyxczcovrmwqxxbnhfzcjjcpgzjjfateajnnvlbwhyppdleahgaypxidkpwmfqwqyofwdqgxhjaxvyrzupfwesmxbjszolgwqvfiozofncbohduqgiswuiyddmwlwubetyaummenkdfptjczxemryuotrrymrfdxtrebpbjtpnuhsbnovhectpjhfhahbqrfbyxggobsweefcwxpqsspyssrmdhuelkkvyjxswjwofngpwfxvknkjviiavorwyfzlnktmfwxkvwkrwdcxjfzikdyswsuxegmhtnxjraqrdchaauazfhtklxsksbhwgjphgbasfnlwqwukprgvihntsyymdrfovaszjywuqygpvjtvlsvvqbvzsmgweiayhlubnbsitvfxawhfmfiatxvqrcwjshvovxknnxnyyfexqycrlyksderlqarqhkxyaqwlwoqcribumrqjtelhwdvaiysgjlvksrfvjlcaiwrirtkkxbwgicyhvakxgdjwnwmubkiazdjkfmotglclqndqjxethoutvjchjbkoasnnfbgrnycucfpeovruguzumgmgddqwjgdvaujhyqsqtoexmnfuluaqbxoofvotvfoiexbnprrxptchmlctzgqtkivsilwgwgvpidpvasurraqfkcmxhdapjrlrnkbklwkrvoaziznlpor",
      "qhxepbshlrhoecdaodgpousbzfcqjxulatciapuftffahhlmxbufgjuxstfjvljybfxnenlacmjqoymvamphpxnolwijwcecgwbcjhgdybfffwoygikvoecdggplfohemfypxfsvdrseyhmvkoovxhdvoavsqqbrsqrkqhbtmgwaurgisloqjixfwfvwtszcxwktkwesaxsmhsvlitegrlzkvfqoiiwxbzskzoewbkxtphapavbyvhzvgrrfriddnsrftfowhdanvhjvurhljmpxvpddxmzfgwwpkjrfgqptrmumoemhfpojnxzwlrxkcafvbhlwrapubhveattfifsmiounhqusvhywnxhwrgamgnesxmzliyzisqrwvkiyderyotxhwspqrrkeczjysfujvovsfcfouykcqyjoobfdgnlswfzjmyucaxuaslzwfnetekymrwbvponiaojdqnbmboldvvitamntwnyaeppjaohwkrisrlrgwcjqqgxeqerjrbapfzurcwxhcwzugcgnirkkrxdthtbmdqgvqxilllrsbwjhwqszrjtzyetwubdrlyakzxcveufvhqugyawvkivwonvmrgnchkzdysngqdibhkyboyftxcvvjoggecjsajbuqkjjxfvynrjsnvtfvgpgveycxidhhfauvjovmnbqgoxsafknluyimkczykwdgvqwlvvgdmufxdypwnajkncoynqticfetcdafvtqszuwfmrdggifokwmkgzuxnhncmnsstffqpqbplypapctctfhqpihavligbrutxmmygiyaklqtakdidvnvrjfteazeqmbgklrgrorudayokxptswwkcircwuhcavhdparjfkjypkyxhbgwxbkvpvrtzjaetahmxevmkhdfyidhrdeejapfbafwmdqjqszwnwzgclitdhlnkaiyldwkwwzvhyorgbysyjbxsspnjdewjxbhpsvj"
    )
  );



//****************************************   Day 9    **********************************************************
// *************************************  709. To Lower Case  **************************************************
// Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.
// You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows:

// Characters ('a' to 'i') are represented by ('1' to '9') respectively.
// Characters ('j' to 'z') are represented by ('10#' to '26#') respectively.
// Return the string formed after mapping.

// The test cases are generated so that a unique mapping will always exist.

var freqAlphabets = function (s) {
    let news = "";
    let re = "";
    for (i=0;i<s.length;i++){
        if ((s[i]>=3) || (s[i+2] !== "#")){
             re = String.fromCharCode(96+Number(s[i]));
  
        }
        else {          
                re =String.fromCharCode(96+Number(s.slice(i,i+2)));
                i +=2;
            
  
        }
        news += re;
    }
    return news;
  
  };
  console.log(freqAlphabets("10#11#12"));
  
  
  
  
  var freqAlphabets = function(s) {
      const base = 'a'.charCodeAt(0) - 1;
      return s.replace(/(\d\d#|\d)/g, c =>
        c[2] === '#'
          ? String.fromCharCode(base + parseInt(c.slice(0, -1)))
          : String.fromCharCode(base + parseInt(c))
      );
    };


// ************************************************** 953. Verifying an Alien Dictionary **************************************************
// In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

// Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.
var isAlienSorted = function (words, order) {
    return words.reduce((a, b) => {
        let len_a = a.length;
        let len_b = b.length;
        if (len_a > 0 && len_b > 0) {
            if (a == b) { return true; }
            if (b.search(a) != -1) { return true; }
            if (a.search(b) != -1) { return false; }
        }
        for (i = 0; i < Math.min(len_a, len_b); i++) {
            if (order.indexOf(a[i]) < order.indexOf(b[i])) { return true; }
            if (order.indexOf(a[i]) > order.indexOf(b[i])) { return false; }
        }
        return false;
    });
};

// OR 
var isAlienSorted = function(words, order) {
    for(let i=1;i<words.length;i++) {
        const a = words[i-1]
        const b = words[i]
        const maxLen = Math.max(a.length, b.length)
        for(let j=0;j<maxLen;j++) {
            const indexA = order.indexOf(a[j])
            const indexB = order.indexOf(b[j])
            if (indexA > indexB) {
                return false
            } else if (indexA < indexB) {
                j=maxLen
            }
        }
    }
    return true
};


// 1128. Number of Equivalent Domino Pairs

// Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d),
// or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.

// Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].

var numEquivDominoPairs = function (dominoes) {
  //   dominoes[4].sort();
  //   console.log(dominoes[4]);
  // console.log(dominoes.length);
  let n = 0;
  let result = [];
  let count = {};
  let test = dominoes.map( item => item.sort() );
  // console.log(test);
  test.forEach(item =>{
   let a=item[0];
   let b=item[1];

   console.log('a,b: '+a,b);
    if (count[item]){
     // console.log('item: '+item);
      count[item] += 1;
      console.log(count)
      return;

    }
    count[item] = 1;


  })

  //console.log('test1 is ', Object.values(count));
  function n1(num) {
    return num*(num-1)/2;
  }
  let sum =0;
  let math1 = Object.values(count).map( cnt => (cnt > 1 ? n1(cnt) : 0) ).reduce((pr,cur,index)=>{
     sum += cur;
    //  console.log(pr, cur, index);
     return sum;
    },0);
  // console.log(math1);




  return sum;
}
 

console.log(
  numEquivDominoPairs([
    [1, 1],
    [2, 1],
    [1, 1],
    [1, 2],
    [1, 2],
    [1, 1],
    [2, 1],
    [2, 2],
    [1, 1]
  ])
);


// ************************************************** Remove Duplicates from Sorted Array **************************************************

/*
 * @param {number[]} nums
 * @return {number}
 */
// Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. 
// The relative order of the elements should be kept the same.

// Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. 
// More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. 
// It does not matter what you leave beyond the first k elements.

// Return k after placing the final result in the first k slots of nums.



var removeDuplicates = function (nums) {
  let k = 0;
  let seen = [];

  nums.forEach((item, index) => {
    if (seen.includes(item) == false) {
      seen.splice(k, 0, item);
      k++;
    } else {
      seen.push("_");
    }
  });
  return seen;
};
console.log(removeDuplicates([1,1,2]));

// Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
var removeDuplicates = function (nums) {
  let k = 0;
  for(let i=nums.length-1;i>=0;i--){
    if (nums[i] == nums[i - 1]) {
      nums.splice(i, 1);
      nums.push("_");
    } else {
      k++;
    }
  }

  return k;
};
console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]));